{"version":3,"file":"ai_conversation.min.js","sources":["../src/ai_conversation.js"],"sourcesContent":["// This file is part of Moodle - https://moodle.org/\n//\n// Moodle is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// Moodle is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with Moodle.  If not, see <https://www.gnu.org/licenses/>.\n\n/**\n * AMD module for AI conversation chat interface.\n *\n * @module     mod_harpiasurvey/ai_conversation\n * @copyright  2025 Your Name\n * @license    https://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later\n */\n\nimport Templates from 'core/templates';\nimport Notification from 'core/notification';\nimport Config from 'core/config';\nimport $ from 'jquery';\n\nlet initialized = false;\n\n// Track current turn for each page (for turns mode).\nconst currentTurns = {};\n\n/**\n * Initialize the AI conversation functionality.\n */\nexport const init = () => {\n    if (initialized) {\n        // eslint-disable-next-line no-console\n        console.log('ai_conversation: Already initialized');\n        return;\n    }\n\n    // eslint-disable-next-line no-console\n    console.log('ai_conversation: Initializing...');\n\n    // Initialize turn tracking for turns mode.\n    $('.ai-conversation-container[data-behavior=\"turns\"]').each(function() {\n        const pageid = parseInt($(this).data('pageid'), 10);\n        if (pageid && !currentTurns[pageid]) {\n            // Get the highest turn number from existing messages.\n            const messagesContainer = $(`#chat-messages-page-${pageid}`);\n            let maxTurn = 0;\n            messagesContainer.find('[data-turn-id]').each(function() {\n                const turnId = parseInt($(this).data('turn-id'), 10);\n                if (turnId && turnId > maxTurn) {\n                    maxTurn = turnId;\n                }\n            });\n            // Current turn is the highest turn, or 1 if no turns exist.\n            currentTurns[pageid] = maxTurn > 0 ? maxTurn : 1;\n            setViewingTurn(pageid, currentTurns[pageid]);\n            updateTurnDisplay(pageid);\n            updateChatLockState(pageid);\n            // Filter messages to show only current turn initially (hide previous).\n            filterMessagesByTurn(pageid, currentTurns[pageid], false);\n        }\n    });\n\n    // Handle send button clicks.\n    $(document).on('click', '.chat-send-btn', function(e) {\n        e.preventDefault();\n        const button = $(this);\n        const cmid = parseInt(button.data('cmid'), 10);\n        const pageid = parseInt(button.data('pageid'), 10);\n\n        if (!cmid || !pageid) {\n            Notification.addNotification({\n                message: 'Missing cmid or pageid',\n                type: 'error'\n            });\n            return;\n        }\n\n        const input = $(`#chat-input-page-${pageid}`);\n        if (input.length === 0) {\n            Notification.addNotification({\n                message: 'Chat input not found',\n                type: 'error'\n            });\n            return;\n        }\n\n        const inputValue = input.val();\n        if (!inputValue) {\n            return;\n        }\n\n        const message = inputValue.trim();\n\n        if (!message) {\n            return;\n        }\n\n        // Check if chat is locked (viewing a past turn).\n        const container = button.closest('.ai-conversation-container');\n        const behavior = container.data('behavior');\n        if (behavior === 'turns') {\n            const viewingTurn = getViewingTurn(pageid);\n            const currentTurn = getCurrentTurn(pageid);\n            if (viewingTurn !== currentTurn) {\n                Notification.addNotification({\n                    message: 'Cannot send messages in a locked turn. ' +\n                        'Navigate to the current turn first.',\n                    type: 'error'\n                });\n                return;\n            }\n        }\n\n        // Get model from container data attribute (first available model).\n        const modelsdata = container.data('models');\n        let modelid = null;\n\n        if (modelsdata) {\n            // modelsdata is a comma-separated string, get first one.\n            const modelids = modelsdata.split(',');\n            if (modelids.length > 0) {\n                modelid = parseInt(modelids[0], 10);\n            }\n        }\n\n        if (!modelid) {\n            Notification.addNotification({\n                message: 'No model available',\n                type: 'error'\n            });\n            return;\n        }\n\n        // Disable input and button.\n        input.prop('disabled', true);\n        button.prop('disabled', true);\n\n        // Clear input.\n        input.val('');\n\n        // Display user message with temporary ID (will be updated with real ID from server).\n        const tempId = 'temp-user-' + Date.now() + '-' + Math.random().toString(36).substr(2, 9);\n        displayUserMessage(pageid, message, tempId);\n\n        // Show loading indicator.\n        const loading = $(`#chat-loading-page-${pageid}`);\n        loading.show();\n\n        // Send message to AI.\n        sendMessage(cmid, pageid, message, modelid, button, input, loading);\n    });\n\n    // Handle Enter key in textarea (Shift+Enter for new line, Enter to send).\n    $(document).on('keydown', '.chat-input', function(e) {\n        if (e.key === 'Enter' && !e.shiftKey) {\n            e.preventDefault();\n            $(this).closest('.ai-conversation-container').find('.chat-send-btn').click();\n        }\n    });\n\n    // Handle save turn evaluation questions button clicks.\n    // Use event delegation on document to catch dynamically added buttons.\n    $(document).on('click', '.save-turn-evaluation-questions-btn', function(e) {\n        e.preventDefault();\n        e.stopPropagation();\n\n        // eslint-disable-next-line no-console\n        console.log('=== Save turn evaluation button clicked! ===');\n\n        const button = $(this);\n        const turnId = parseInt(button.data('turn-id'), 10);\n        const pageid = parseInt(button.data('pageid'), 10);\n        const cmid = parseInt(button.data('cmid'), 10);\n\n        // eslint-disable-next-line no-console\n        console.log('Button element:', button[0]);\n        // eslint-disable-next-line no-console\n        console.log('Button data attributes:', {\n            'data-turn-id': button.attr('data-turn-id'),\n            'data-pageid': button.attr('data-pageid'),\n            'data-cmid': button.attr('data-cmid')\n        });\n        // eslint-disable-next-line no-console\n        console.log('Parsed values:', {turnId, pageid, cmid});\n\n        // Validate turnId (must be >= 1), pageid and cmid (must be > 0).\n        if (!turnId || turnId < 1 || !pageid || pageid <= 0 || !cmid || cmid <= 0) {\n            // eslint-disable-next-line no-console\n            console.error('Validation failed:', {turnId, pageid, cmid});\n            Notification.addNotification({\n                message: 'Missing required data (turnId: ' + turnId + ', pageid: ' + pageid + ', cmid: ' + cmid + ')',\n                type: 'error'\n            });\n            return;\n        }\n\n        // Get all question responses from the evaluation container.\n        const evaluationContainer = button.closest('.turn-evaluation-questions');\n        const responses = {};\n\n        evaluationContainer.find('[data-questionid]').each(function() {\n            const questionId = $(this).data('questionid');\n            const questionType = $(this).data('questiontype');\n            let responseValue = null;\n\n            if (questionType === 'multiplechoice') {\n                // Multiple choice: collect all checked values.\n                const checked = evaluationContainer.find(`input[name=\"question_${questionId}_turn[]\"]:checked`);\n                const values = [];\n                checked.each(function() {\n                    values.push($(this).val());\n                });\n                responseValue = values.length > 0 ? JSON.stringify(values) : null;\n            } else if (questionType === 'select' || questionType === 'singlechoice' || questionType === 'likert') {\n                // Single choice: get selected value.\n                const selectSelector = `select[name=\"question_${questionId}_turn\"]`;\n                const inputSelector = `input[name=\"question_${questionId}_turn\"]:checked`;\n                const selected = evaluationContainer.find(selectSelector + ', ' + inputSelector);\n                responseValue = selected.length > 0 ? selected.val() : null;\n            } else if (questionType === 'number' || questionType === 'shorttext') {\n                // Number or short text: get input value.\n                const input = evaluationContainer.find(`input[name=\"question_${questionId}_turn\"]`);\n                responseValue = input.length > 0 ? input.val() : null;\n            } else if (questionType === 'longtext') {\n                // Long text: get textarea value.\n                const textarea = evaluationContainer.find(`textarea[name=\"question_${questionId}_turn\"]`);\n                responseValue = textarea.length > 0 ? textarea.val() : null;\n            }\n\n            if (responseValue !== null && responseValue !== '') {\n                responses[questionId] = responseValue;\n            }\n        });\n\n        // Disable button.\n        button.prop('disabled', true);\n        const originalText = button.text();\n        button.text('Saving...');\n\n        // Save all responses for this turn.\n        saveTurnEvaluationQuestions(cmid, pageid, turnId, responses, button, originalText);\n    });\n\n    // Handle next turn button clicks.\n    $(document).on('click', '.next-turn-btn', function(e) {\n        e.preventDefault();\n        const button = $(this);\n        const pageid = parseInt(button.data('pageid'), 10);\n        const cmid = parseInt(button.data('cmid'), 10);\n\n        if (!pageid || !cmid) {\n            Notification.addNotification({\n                message: 'Missing pageid or cmid',\n                type: 'error'\n            });\n            return;\n        }\n\n        const viewingTurn = getViewingTurn(pageid);\n        const currentTurn = getCurrentTurn(pageid);\n\n        if (viewingTurn < currentTurn) {\n            // If viewing a past turn, go to current turn.\n            setViewingTurn(pageid, currentTurn);\n            updateTurnDisplay(pageid);\n            updateChatLockState(pageid);\n            filterMessagesByTurn(pageid, currentTurn, false); // Hide previous messages.\n            // Render questions and load saved responses for current turn.\n            ensureTurnEvaluationQuestionsRendered(pageid, currentTurn).then(() => {\n                loadTurnEvaluationResponses(pageid, currentTurn);\n            });\n        } else {\n            // If viewing current turn, create next turn.\n            // The next turn becomes the new current turn, so chat should remain unlocked.\n            const nextTurn = currentTurn + 1;\n            setViewingTurn(pageid, nextTurn);\n            currentTurns[pageid] = nextTurn;\n            updateTurnDisplay(pageid);\n            updateChatLockState(pageid); // This will unlock since nextTurn === currentTurn now.\n            filterMessagesByTurn(pageid, nextTurn, false); // Hide previous messages by default.\n            // Render questions for new turn and clear form (no saved responses yet).\n            ensureTurnEvaluationQuestionsRendered(pageid, nextTurn).then(() => {\n                clearTurnEvaluationForm(pageid, nextTurn);\n            });\n        }\n    });\n\n    // Handle previous turn button clicks.\n    $(document).on('click', '.prev-turn-btn', function(e) {\n        e.preventDefault();\n        const button = $(this);\n        const pageid = parseInt(button.data('pageid'), 10);\n\n        if (!pageid) {\n            Notification.addNotification({\n                message: 'Missing pageid',\n                type: 'error'\n            });\n            return;\n        }\n\n        const viewingTurn = getViewingTurn(pageid);\n        if (viewingTurn > 1) {\n            const prevTurn = viewingTurn - 1;\n            setViewingTurn(pageid, prevTurn);\n            updateTurnDisplay(pageid);\n            updateChatLockState(pageid);\n            filterMessagesByTurn(pageid, prevTurn, false); // Hide previous messages.\n            // Render questions and load saved responses for previous turn.\n            ensureTurnEvaluationQuestionsRendered(pageid, prevTurn).then(() => {\n                loadTurnEvaluationResponses(pageid, prevTurn);\n            });\n        }\n    });\n\n    // Handle show/hide previous messages button clicks.\n    $(document).on('click', '.show-previous-messages-btn', function(e) {\n        e.preventDefault();\n        const button = $(this);\n        const pageid = parseInt(button.data('pageid'), 10);\n        const showing = button.data('showing') || false;\n        const viewingTurn = getViewingTurn(pageid);\n\n        if (!pageid) {\n            return;\n        }\n\n        // Toggle showing previous messages.\n        filterMessagesByTurn(pageid, viewingTurn, !showing);\n    });\n\n    initialized = true;\n\n    // eslint-disable-next-line no-console\n    console.log('ai_conversation: Initialization complete. Event handlers registered.');\n};\n\n/**\n * Display user message in chat.\n *\n * @param {number} pageid Page ID\n * @param {string} message Message content\n * @param {number} messageid Optional message ID to prevent duplicates\n */\nconst displayUserMessage = (pageid, message, messageid = null) => {\n    const messagesContainer = $(`#chat-messages-page-${pageid}`);\n    const placeholder = messagesContainer.find('.text-muted.text-center');\n\n    if (placeholder.length > 0) {\n        placeholder.remove();\n    }\n\n    // Check if message already exists (by ID).\n    if (messageid) {\n        const existing = messagesContainer.find(`[data-messageid=\"${messageid}\"]`);\n        if (existing.length > 0) {\n            return; // Message already displayed.\n        }\n    }\n\n    // Also check for duplicate content in the last few messages (prevent double-sending).\n    const recentMessages = messagesContainer.find('.message').slice(-3);\n    let isDuplicate = false;\n    recentMessages.each(function() {\n        const contentEl = $(this).find('.content');\n        if (contentEl.length === 0) {\n            return true; // Continue to next message.\n        }\n        const msgContent = contentEl.text();\n        if (msgContent && msgContent.trim() === message.trim()) {\n            isDuplicate = true;\n            return false; // Break loop.\n        }\n    });\n    if (isDuplicate && !messageid) {\n        // If it's a duplicate and no ID provided, don't add it.\n        return;\n    }\n\n    // Double-check for duplicate before rendering (race condition protection).\n    if (messageid) {\n        const existing = messagesContainer.find(`[data-messageid=\"${messageid}\"]`);\n        if (existing.length > 0) {\n            return; // Message already displayed.\n        }\n    }\n\n    // Ensure message is a string.\n    const safeMessage = (message && typeof message === 'string') ? message : '';\n\n    // Get current viewing turn for turns mode.\n    const container = $(`#chat-messages-page-${pageid}`).closest('.ai-conversation-container');\n    const behavior = container.data('behavior');\n    const viewingTurn = behavior === 'turns' ? getViewingTurn(pageid) : null;\n\n    const templateData = {\n        content: safeMessage,\n        id: messageid || 'temp-' + Date.now()\n    };\n\n    if (viewingTurn) {\n        templateData.turn_id = viewingTurn;\n    }\n\n    Templates.render('mod_harpiasurvey/chat_user_message', templateData).then((html) => {\n        // Final check before appending (prevent race conditions).\n        if (messageid) {\n            const existing = messagesContainer.find(`[data-messageid=\"${messageid}\"]`);\n            if (existing.length > 0) {\n                return; // Message was added while we were rendering.\n            }\n        }\n        Templates.appendNodeContents(messagesContainer[0], html);\n        // Scroll after a brief delay to ensure DOM is fully updated.\n        setTimeout(() => {\n            scrollToBottom(pageid);\n        }, 50);\n    }).catch(() => {\n        // Fallback if template fails.\n        // Final check before appending.\n        if (messageid) {\n            const existing = messagesContainer.find(`[data-messageid=\"${messageid}\"]`);\n            if (existing.length > 0) {\n                return;\n            }\n        }\n        let messageHtml = '<div class=\"message my-3\" data-messageid=\"' + (messageid || 'temp-' + Date.now()) + '\"';\n        if (viewingTurn) {\n            messageHtml += ' data-turn-id=\"' + viewingTurn + '\"';\n        }\n        messageHtml += '><div class=\"d-flex justify-content-end\">' +\n            '<div class=\"border rounded p-2 bg-primary text-white\" style=\"max-width: 80%;\">' +\n            '<div class=\"content\">' + message + '</div>' +\n            '</div></div></div>';\n        messagesContainer.append(messageHtml);\n        // Scroll after a brief delay to ensure DOM is fully updated.\n        setTimeout(() => {\n            scrollToBottom(pageid);\n        }, 50);\n    });\n};\n\n/**\n * Display AI message in chat.\n *\n * @param {number} pageid Page ID\n * @param {string} content Message content\n * @param {number} messageid Message ID\n * @param {number|null} turnId Turn ID (for turns mode)\n */\nconst displayAIMessage = (pageid, content, messageid, turnId = null) => {\n    const messagesContainer = $(`#chat-messages-page-${pageid}`);\n\n    if (!messageid) {\n        // eslint-disable-next-line no-console\n        console.error('displayAIMessage called without messageid');\n        return;\n    }\n\n    if (!content) {\n        // eslint-disable-next-line no-console\n        console.error('displayAIMessage called without content');\n        return;\n    }\n\n    // Check if message already exists.\n    const existing = messagesContainer.find(`[data-messageid=\"${messageid}\"]`);\n    if (existing.length > 0) {\n        // eslint-disable-next-line no-console\n        console.log('AI message already displayed:', messageid);\n        return; // Message already displayed.\n    }\n\n    // Ensure content is a string and not empty.\n    const safeContent = (content && typeof content === 'string') ? content : '';\n\n    const templateData = {\n        id: messageid,\n        content: safeContent\n    };\n\n    if (turnId) {\n        templateData.turn_id = turnId;\n        templateData.pageid = pageid;\n        // Get cmid from container.\n        const container = $(`#chat-messages-page-${pageid}`).closest('.ai-conversation-container');\n        templateData.cmid = container.data('cmid');\n    }\n\n    Templates.render('mod_harpiasurvey/chat_ai_message', templateData).then((html) => {\n        // Final check before appending (prevent race conditions).\n        const existingCheck = messagesContainer.find(`[data-messageid=\"${messageid}\"]`);\n        if (existingCheck.length > 0) {\n            return; // Message was added while we were rendering.\n        }\n        Templates.appendNodeContents(messagesContainer[0], html);\n\n        // If this is a turn-based message, load evaluation questions.\n        if (turnId) {\n            setTimeout(() => {\n                ensureTurnEvaluationQuestionsRendered(pageid, turnId).then(() => {\n                    // Load saved responses for this turn.\n                    loadTurnEvaluationResponses(pageid, turnId);\n                });\n            }, 100);\n\n            // Update current turn if this is a new turn.\n            const currentTurn = getCurrentTurn(pageid);\n            if (turnId > currentTurn) {\n                currentTurns[pageid] = turnId;\n                updateTurnDisplay(pageid);\n            }\n\n            // After displaying AI message, filter to show only current turn (hide previous).\n            const viewingTurn = getViewingTurn(pageid);\n            if (viewingTurn === turnId) {\n                filterMessagesByTurn(pageid, turnId, false);\n            }\n        }\n\n        // Scroll after a brief delay to ensure DOM is fully updated.\n        setTimeout(() => {\n            scrollToBottom(pageid);\n        }, 50);\n    }).catch(() => {\n        // Fallback if template fails.\n        // Final check before appending.\n        const existingCheck = messagesContainer.find(`[data-messageid=\"${messageid}\"]`);\n        if (existingCheck.length > 0) {\n            return;\n        }\n        const messageHtml = '<div class=\"message my-3\" data-messageid=\"' + messageid + '\">' +\n            '<div class=\"d-flex\">' +\n            '<div class=\"border rounded p-2 bg-light\" style=\"max-width: 80%;\">' +\n            '<div class=\"content\">' + content + '</div>' +\n            '</div></div></div>';\n        messagesContainer.append(messageHtml);\n        // Scroll after a brief delay to ensure DOM is fully updated.\n        setTimeout(() => {\n            scrollToBottom(pageid);\n        }, 50);\n    });\n};\n\n/**\n * Send message to AI via AJAX.\n *\n * @param {number} cmid Course module ID\n * @param {number} pageid Page ID\n * @param {string} message Message content\n * @param {number} modelid Model ID\n * @param {jQuery} button Send button element\n * @param {jQuery} input Input textarea element\n * @param {jQuery} loading Loading indicator element\n */\nconst sendMessage = (cmid, pageid, message, modelid, button, input, loading) => {\n    // Get current viewing turn (for turns mode).\n    const container = $(`#chat-messages-page-${pageid}`).closest('.ai-conversation-container');\n    const behavior = container.data('behavior');\n    const viewingTurn = behavior === 'turns' ? getViewingTurn(pageid) : null;\n\n    const params = new URLSearchParams({\n        action: 'send_ai_message',\n        cmid: cmid,\n        pageid: pageid,\n        message: message,\n        modelid: modelid,\n        sesskey: Config.sesskey\n    });\n\n    // For turns mode, send the viewing turn so backend can use it.\n    if (behavior === 'turns' && viewingTurn) {\n        params.append('turn_id', viewingTurn);\n    }\n\n    fetch(Config.wwwroot + '/mod/harpiasurvey/ajax.php?' + params.toString(), {\n        method: 'GET',\n        headers: {\n            'Content-Type': 'application/json'\n        }\n    })\n    .then(response => {\n        if (!response.ok) {\n            throw new Error('HTTP error! status: ' + response.status);\n        }\n        return response.json();\n    })\n    .then(data => {\n        loading.hide();\n\n        if (data.success) {\n            // Update user message with actual ID from server (if we have parentid).\n            if (data.parentid) {\n                // Find the last user message (the one we just sent) and update its ID and turn_id.\n                const messagesContainer = $(`#chat-messages-page-${pageid}`);\n                const userMessages = messagesContainer.find('.message').filter(function() {\n                    return $(this).find('.bg-primary').length > 0;\n                });\n                if (userMessages.length > 0) {\n                    const lastUserMsg = userMessages.last();\n                    const currentId = lastUserMsg.attr('data-messageid');\n                    // Only update if it's a temporary ID.\n                    if (currentId && currentId.startsWith('temp-')) {\n                        lastUserMsg.attr('data-messageid', data.parentid);\n                        // Update turn_id if provided.\n                        if (data.user_message_turn_id) {\n                            lastUserMsg.attr('data-turn-id', data.user_message_turn_id);\n                        }\n                    }\n                }\n            }\n\n            // Display AI response (check for duplicates first).\n            if (data.messageid && data.content) {\n                displayAIMessage(pageid, data.content, data.messageid, data.turn_id);\n\n                // Update current turn if a new turn was created.\n                if (data.turn_id) {\n                    const currentTurn = getCurrentTurn(pageid);\n                    if (data.turn_id > currentTurn) {\n                        currentTurns[pageid] = data.turn_id;\n                        updateTurnDisplay(pageid);\n                        updateChatLockState(pageid);\n                    }\n                }\n            } else {\n                Notification.addNotification({\n                    message: 'Received response but missing message ID or content',\n                    type: 'error'\n                });\n            }\n        } else {\n            Notification.addNotification({\n                message: data.message || 'Error sending message',\n                type: 'error'\n            });\n        }\n\n        // Re-enable input and button.\n        input.prop('disabled', false);\n        button.prop('disabled', false);\n        input.focus();\n    })\n    .catch(error => {\n        loading.hide();\n        // eslint-disable-next-line no-console\n        console.error('Error sending message:', error);\n        Notification.addNotification({\n            message: 'Error sending message: ' + error.message,\n            type: 'error'\n        });\n        input.prop('disabled', false);\n        button.prop('disabled', false);\n        input.focus();\n    });\n};\n\n/**\n * Scroll chat to bottom.\n *\n * @param {number} pageid Page ID\n */\nconst scrollToBottom = (pageid) => {\n    const messagesContainer = $(`#chat-messages-page-${pageid}`);\n    if (messagesContainer.length === 0) {\n        return;\n    }\n\n    // Use requestAnimationFrame to ensure DOM is updated before scrolling.\n    requestAnimationFrame(() => {\n        const container = messagesContainer[0];\n        if (container) {\n            container.scrollTop = container.scrollHeight;\n        }\n    });\n};\n\n/**\n * Ensure turn evaluation questions are rendered for a specific turn.\n * This will render them if they don't exist, or do nothing if they already exist.\n *\n * @param {number} pageid Page ID\n * @param {number} turnId Turn ID\n * @return {Promise} Promise that resolves when questions are rendered\n */\nconst ensureTurnEvaluationQuestionsRendered = (pageid, turnId) => {\n    // Check if questions are already rendered for this turn.\n    // Look in the container below the chat, not inside messages.\n    const containerWrapper = $(`#turn-evaluation-questions-container-${pageid}`);\n    if (containerWrapper.length === 0) {\n        // Container wrapper doesn't exist - not in turns mode or page not loaded yet.\n        return Promise.resolve();\n    }\n\n    const existingContainer = containerWrapper.find(`.turn-evaluation-questions[data-turn-id=\"${turnId}\"]`);\n    if (existingContainer.length > 0 && existingContainer.find('.question-item').length > 0) {\n        // Questions already rendered, return resolved promise.\n        return Promise.resolve();\n    }\n\n    // Questions not rendered yet, render them.\n    return loadTurnEvaluationQuestions(pageid, turnId);\n};\n\n/**\n * Load and render turn evaluation questions for a specific turn.\n *\n * @param {number} pageid Page ID\n * @param {number} turnId Turn ID\n * @return {Promise} Promise that resolves when questions are rendered\n */\nconst loadTurnEvaluationQuestions = (pageid, turnId) => {\n    const container = $(`#chat-messages-page-${pageid}`).closest('.ai-conversation-container');\n    const questionsDataEl = $(`#turn-evaluation-questions-data-${pageid}`);\n\n    if (questionsDataEl.length === 0) {\n        return Promise.resolve(); // No evaluation questions configured.\n    }\n\n    try {\n        const allQuestions = JSON.parse(questionsDataEl.text());\n        // Filter questions that should appear for this turn (min_turn <= turnId).\n        const questionsForTurn = allQuestions.filter(q => (q.min_turn || 1) <= turnId);\n\n        if (questionsForTurn.length === 0) {\n            return Promise.resolve(); // No questions for this turn.\n        }\n\n        // Find or create the evaluation container below the chat (not inside messages).\n        const containerWrapper = $(`#turn-evaluation-questions-container-${pageid}`);\n        if (containerWrapper.length === 0) {\n            // Container wrapper doesn't exist - this shouldn't happen in turns mode, but handle gracefully.\n            return Promise.resolve();\n        }\n\n        // Find or create the container for this specific turn.\n        let evaluationContainer = containerWrapper.find(`.turn-evaluation-questions[data-turn-id=\"${turnId}\"]`);\n        if (evaluationContainer.length === 0) {\n            // Create container for this turn.\n            const containerHtml = `<div class=\"turn-evaluation-questions mt-3 pt-3 border-top\" data-turn-id=\"${turnId}\" data-pageid=\"${pageid}\" data-cmid=\"${cmid}\"></div>`;\n            containerWrapper.append(containerHtml);\n            evaluationContainer = containerWrapper.find(`.turn-evaluation-questions[data-turn-id=\"${turnId}\"]`);\n        }\n\n        // Render questions using the same template as regular questions.\n        const cmid = container.data('cmid');\n        // eslint-disable-next-line no-console\n        console.log('Rendering turn evaluation questions:', {pageid, turnId, cmid, questionsCount: questionsForTurn.length});\n\n        return Templates.render('mod_harpiasurvey/turn_evaluation_questions', {\n            questions: questionsForTurn,\n            has_questions: questionsForTurn.length > 0,\n            turn_id: turnId,\n            pageid: pageid,\n            cmid: cmid\n        }).then((html) => {\n            // Clear container first to remove any previous questions.\n            evaluationContainer.html(html);\n            // eslint-disable-next-line no-console\n            console.log('Turn evaluation questions rendered. HTML length:', html.length);\n            // Verify button exists after rendering.\n            const button = evaluationContainer.find('.save-turn-evaluation-questions-btn');\n            // eslint-disable-next-line no-console\n            console.log('Save button found after render:', button.length, 'Button data:', {\n                turnId: button.data('turn-id'),\n                pageid: button.data('pageid'),\n                cmid: button.data('cmid')\n            });\n            // Return promise that resolves after rendering is complete.\n            return Promise.resolve();\n        }).catch((error) => {\n            // eslint-disable-next-line no-console\n            console.error('Error rendering turn evaluation questions:', error);\n            return Promise.reject(error);\n        });\n    } catch (error) {\n        // eslint-disable-next-line no-console\n        console.error('Error parsing turn evaluation questions data:', error);\n    }\n};\n\n/**\n * Save turn evaluation questions responses.\n *\n * @param {number} cmid Course module ID\n * @param {number} pageid Page ID\n * @param {number} turnId Turn ID\n * @param {object} responses Object with questionId -> responseValue mappings\n * @param {jQuery} button Save button element\n * @param {string} originalText Original button text\n */\nconst saveTurnEvaluationQuestions = (cmid, pageid, turnId, responses, button, originalText) => {\n    // Validate turnId before proceeding.\n    if (!turnId || turnId < 1) {\n        Notification.addNotification({\n            message: 'Invalid turn ID',\n            type: 'error'\n        });\n        button.prop('disabled', false);\n        button.text(originalText);\n        return;\n    }\n\n    // Save each response individually.\n    const savePromises = Object.keys(responses).map(questionId => {\n        const params = new URLSearchParams({\n            action: 'save_response',\n            cmid: cmid,\n            pageid: pageid,\n            questionid: questionId,\n            response: responses[questionId],\n            turn_id: turnId.toString(), // Ensure it's a string for URLSearchParams.\n            sesskey: Config.sesskey\n        });\n\n        // Debug: Log the URL being called.\n        const url = Config.wwwroot + '/mod/harpiasurvey/ajax.php?' + params.toString();\n        // eslint-disable-next-line no-console\n        console.log('Saving turn evaluation response:', {\n            questionId: questionId,\n            turnId: turnId,\n            url: url\n        });\n\n        return fetch(url, {\n            method: 'GET',\n            headers: {\n                'Content-Type': 'application/json'\n            }\n        }).then(response => response.json()).then(data => {\n            // eslint-disable-next-line no-console\n            console.log('Response from save:', data);\n            return data;\n        });\n    });\n\n    Promise.all(savePromises).then(results => {\n        const allSuccess = results.every(r => r.success);\n        if (allSuccess) {\n            // Don't show notification for turn evaluation questions - they save silently.\n            // Just update button state and show timestamps.\n            const containerWrapper = $(`#turn-evaluation-questions-container-${pageid}`);\n            const evaluationContainer = containerWrapper.find(`.turn-evaluation-questions[data-turn-id=\"${turnId}\"]`);\n            const now = Math.floor(Date.now() / 1000); // Current timestamp in seconds.\n            \n            // Show timestamps for all saved questions.\n            Object.keys(responses).forEach(questionId => {\n                showTurnEvaluationTimestamp(evaluationContainer, questionId, now);\n            });\n        } else {\n            Notification.addNotification({\n                message: 'Some responses could not be saved',\n                type: 'error'\n            });\n        }\n        button.prop('disabled', false);\n        button.text(originalText);\n    }).catch(error => {\n        // eslint-disable-next-line no-console\n        console.error('Error saving turn evaluation questions:', error);\n        Notification.addNotification({\n            message: 'Error saving responses: ' + error.message,\n            type: 'error'\n        });\n        button.prop('disabled', false);\n        button.text(originalText);\n    });\n};\n\n/**\n * Load saved responses for a specific turn and populate the form.\n *\n * @param {number} pageid Page ID\n * @param {number} turnId Turn ID\n */\nconst loadTurnEvaluationResponses = (pageid, turnId) => {\n    const container = $(`#chat-messages-page-${pageid}`).closest('.ai-conversation-container');\n    const cmid = container.data('cmid');\n    const containerWrapper = $(`#turn-evaluation-questions-container-${pageid}`);\n    const evaluationContainer = containerWrapper.find(`.turn-evaluation-questions[data-turn-id=\"${turnId}\"]`);\n\n    if (evaluationContainer.length === 0) {\n        return; // Container not found.\n    }\n\n    const params = new URLSearchParams({\n        action: 'get_turn_responses',\n        cmid: cmid,\n        pageid: pageid,\n        turn_id: turnId,\n        sesskey: Config.sesskey\n    });\n\n    fetch(Config.wwwroot + '/mod/harpiasurvey/ajax.php?' + params.toString(), {\n        method: 'GET',\n        headers: {\n            'Content-Type': 'application/json'\n        }\n    })\n    .then(response => response.json())\n    .then(data => {\n        if (data.success && data.responses && Object.keys(data.responses).length > 0) {\n            // Populate form fields with saved responses.\n            Object.keys(data.responses).forEach(questionId => {\n                const responseData = data.responses[questionId];\n                const responseValue = typeof responseData === 'object' ? responseData.response : responseData;\n                const timestamp = typeof responseData === 'object' ? responseData.timemodified : null;\n                \n                const questionItem = evaluationContainer.find(`[data-questionid=\"${questionId}\"]`);\n                const questionType = questionItem.data('questiontype');\n\n                if (questionType === 'multiplechoice') {\n                    // Multiple choice: parse JSON and check boxes.\n                    try {\n                        const values = JSON.parse(responseValue);\n                        if (Array.isArray(values)) {\n                            values.forEach(val => {\n                                const selector = `input[name=\"question_${questionId}_turn[]\"][value=\"${val}\"]`;\n                                evaluationContainer.find(selector).prop('checked', true);\n                            });\n                        }\n                    } catch (e) {\n                        // Invalid JSON, ignore.\n                    }\n                } else if (questionType === 'select') {\n                    // Select: set selected option.\n                    evaluationContainer.find(`select[name=\"question_${questionId}_turn\"]`).val(responseValue);\n                } else if (questionType === 'singlechoice' || questionType === 'likert') {\n                    // Single choice: check radio button.\n                    const selector = `input[name=\"question_${questionId}_turn\"][value=\"${responseValue}\"]`;\n                    evaluationContainer.find(selector).prop('checked', true);\n                } else if (questionType === 'number' || questionType === 'shorttext') {\n                    // Number or short text: set input value.\n                    evaluationContainer.find(`input[name=\"question_${questionId}_turn\"]`).val(responseValue);\n                } else if (questionType === 'longtext') {\n                    // Long text: set textarea value.\n                    evaluationContainer.find(`textarea[name=\"question_${questionId}_turn\"]`).val(responseValue);\n                }\n\n                // Show timestamp if available.\n                if (timestamp) {\n                    showTurnEvaluationTimestamp(evaluationContainer, questionId, timestamp);\n                } else {\n                    hideTurnEvaluationTimestamp(evaluationContainer, questionId);\n                }\n            });\n        } else {\n            // No responses found - clear the form.\n            clearTurnEvaluationForm(pageid, turnId);\n            // Hide all timestamps.\n            evaluationContainer.find('.turn-evaluation-saved-message').remove();\n        }\n    })\n    .catch(error => {\n        // eslint-disable-next-line no-console\n        console.error('Error loading turn evaluation responses:', error);\n    });\n};\n\n/**\n * Clear the form for a specific turn (used when creating a new turn).\n *\n * @param {number} pageid Page ID\n * @param {number} turnId Turn ID\n */\nconst clearTurnEvaluationForm = (pageid, turnId) => {\n    const containerWrapper = $(`#turn-evaluation-questions-container-${pageid}`);\n    const evaluationContainer = containerWrapper.find(`.turn-evaluation-questions[data-turn-id=\"${turnId}\"]`);\n\n    if (evaluationContainer.length === 0) {\n        return; // Container not found.\n    }\n\n    // Clear all form fields.\n    evaluationContainer.find('input[type=\"radio\"]').prop('checked', false);\n    evaluationContainer.find('input[type=\"checkbox\"]').prop('checked', false);\n    evaluationContainer.find('select').val('');\n    evaluationContainer.find('input[type=\"text\"], input[type=\"number\"]').val('');\n    evaluationContainer.find('textarea').val('');\n\n    // Hide all timestamps.\n    evaluationContainer.find('.turn-evaluation-saved-message').remove();\n};\n\n/**\n * Show timestamp for a turn evaluation question.\n *\n * @param {jQuery} evaluationContainer Container element\n * @param {number} questionId Question ID\n * @param {number} timestamp Unix timestamp\n */\nconst showTurnEvaluationTimestamp = (evaluationContainer, questionId, timestamp) => {\n    // Remove existing timestamp if any.\n    hideTurnEvaluationTimestamp(evaluationContainer, questionId);\n\n    const questionItem = evaluationContainer.find(`[data-questionid=\"${questionId}\"]`);\n    if (questionItem.length === 0) {\n        return;\n    }\n\n    // Format timestamp.\n    const date = new Date(timestamp * 1000);\n    const datetimeStr = date.toLocaleString();\n\n    // Create timestamp message.\n    const messageHtml = '<div class=\"mt-2 small text-muted turn-evaluation-saved-message\" ' +\n        `data-questionid=\"${questionId}\">` +\n        '<i class=\"fa fa-check-circle\" aria-hidden=\"true\"></i> ' +\n        `Saved on ${datetimeStr}</div>`;\n\n    questionItem.append(messageHtml);\n};\n\n/**\n * Hide timestamp for a turn evaluation question.\n *\n * @param {jQuery} evaluationContainer Container element\n * @param {number} questionId Question ID\n */\nconst hideTurnEvaluationTimestamp = (evaluationContainer, questionId) => {\n    evaluationContainer.find(`.turn-evaluation-saved-message[data-questionid=\"${questionId}\"]`).remove();\n};\n\n/**\n * Get the current turn for a page (highest turn with messages).\n *\n * @param {number} pageid Page ID\n * @return {number} Current turn number\n */\nconst getCurrentTurn = (pageid) => {\n    return currentTurns[pageid] || 1;\n};\n\n/**\n * Get the viewing turn for a page (which turn is being displayed).\n *\n * @param {number} pageid Page ID\n * @return {number} Viewing turn number\n */\nconst getViewingTurn = (pageid) => {\n    const container = $(`#chat-messages-page-${pageid}`).closest('.ai-conversation-container');\n    return parseInt(container.data('viewing-turn') || getCurrentTurn(pageid), 10);\n};\n\n/**\n * Set the viewing turn for a page.\n *\n * @param {number} pageid Page ID\n * @param {number} turn Turn number\n */\nconst setViewingTurn = (pageid, turn) => {\n    const container = $(`#chat-messages-page-${pageid}`).closest('.ai-conversation-container');\n    container.data('viewing-turn', turn);\n};\n\n/**\n * Update turn display (badge and navigation buttons).\n *\n * @param {number} pageid Page ID\n */\nconst updateTurnDisplay = (pageid) => {\n    const viewingTurn = getViewingTurn(pageid);\n    const currentTurn = getCurrentTurn(pageid);\n\n    // Update turn number badge.\n    $(`#current-turn-number-${pageid}`).text(viewingTurn);\n\n    // Show/hide previous button.\n    const prevBtn = $(`.prev-turn-btn[data-pageid=\"${pageid}\"]`);\n    if (viewingTurn > 1) {\n        prevBtn.show();\n    } else {\n        prevBtn.hide();\n    }\n\n    // Update next button text (if viewing current turn, show \"Create next turn\", otherwise show \"Go to current\").\n    const nextBtn = $(`.next-turn-btn[data-pageid=\"${pageid}\"]`);\n    if (viewingTurn < currentTurn) {\n        // Use direct text since we can't use Mustache here.\n        nextBtn.html('Go to current turn <i class=\"fa fa-chevron-right\"></i>');\n    } else {\n        nextBtn.html('Create next turn <i class=\"fa fa-chevron-right\"></i>');\n    }\n};\n\n/**\n * Update chat lock state (disable input if viewing past turn).\n *\n * @param {number} pageid Page ID\n */\nconst updateChatLockState = (pageid) => {\n    const viewingTurn = getViewingTurn(pageid);\n    const currentTurn = getCurrentTurn(pageid);\n    const input = $(`#chat-input-page-${pageid}`);\n    const sendBtn = $(`.chat-send-btn[data-pageid=\"${pageid}\"]`);\n    const lockMessage = $(`#turn-locked-message-${pageid}`);\n\n    if (viewingTurn < currentTurn) {\n        // Viewing a past turn - lock chat.\n        input.prop('disabled', true);\n        sendBtn.prop('disabled', true);\n        if (lockMessage.length > 0) {\n            lockMessage.show();\n        }\n    } else {\n        // Viewing current turn - unlock chat.\n        input.prop('disabled', false);\n        sendBtn.prop('disabled', false);\n        if (lockMessage.length > 0) {\n            lockMessage.hide();\n        }\n    }\n};\n\n/**\n * Filter messages by turn (show only messages from specified turn, hide previous turns).\n *\n * @param {number} pageid Page ID\n * @param {number} turnId Turn ID\n * @param {boolean} showPrevious Whether to show previous turn messages\n */\nconst filterMessagesByTurn = (pageid, turnId, showPrevious = false) => {\n    const messagesContainer = $(`#chat-messages-page-${pageid}`);\n    const toggleContainer = $(`#previous-messages-toggle-${pageid}`);\n    let hasPreviousMessages = false;\n\n    // Show all messages from this turn or earlier (for context).\n    messagesContainer.find('.message').each(function() {\n        const messageTurnId = $(this).data('turn-id');\n        if (messageTurnId) {\n            const msgTurn = parseInt(messageTurnId, 10);\n            // Show if message is from this turn.\n            if (msgTurn === turnId) {\n                $(this).show();\n                $(this).removeClass('previous-turn-message');\n            } else if (msgTurn < turnId) {\n                // Previous turn message.\n                hasPreviousMessages = true;\n                if (showPrevious) {\n                    $(this).show();\n                    $(this).addClass('previous-turn-message');\n                } else {\n                    $(this).hide();\n                    $(this).addClass('previous-turn-message');\n                }\n            } else {\n                // Future turn message - always hide.\n                $(this).hide();\n                $(this).removeClass('previous-turn-message');\n            }\n        } else {\n            // Messages without turn_id (shouldn't happen in turns mode, but show them anyway).\n            $(this).show();\n            $(this).removeClass('previous-turn-message');\n        }\n    });\n\n    // Show/hide toggle button if there are previous messages.\n    if (hasPreviousMessages && turnId > 1) {\n        toggleContainer.show();\n        const toggleBtn = toggleContainer.find('.show-previous-messages-btn');\n        if (showPrevious) {\n            toggleBtn.html('<i class=\"fa fa-chevron-up\"></i> Hide previous messages');\n            toggleBtn.data('showing', true);\n        } else {\n            toggleBtn.html('<i class=\"fa fa-chevron-down\"></i> Show previous messages');\n            toggleBtn.data('showing', false);\n        }\n    } else {\n        toggleContainer.hide();\n    }\n\n    // Scroll to bottom after filtering.\n    setTimeout(() => {\n        scrollToBottom(pageid);\n    }, 50);\n};\n"],"names":["initialized","currentTurns","console","log","each","pageid","parseInt","this","data","messagesContainer","maxTurn","find","turnId","setViewingTurn","updateTurnDisplay","updateChatLockState","filterMessagesByTurn","document","on","e","preventDefault","button","cmid","addNotification","message","type","input","length","inputValue","val","trim","container","closest","getViewingTurn","getCurrentTurn","modelsdata","modelid","modelids","split","prop","tempId","Date","now","Math","random","toString","substr","displayUserMessage","loading","show","sendMessage","key","shiftKey","click","stopPropagation","attr","error","evaluationContainer","responses","questionId","questionType","responseValue","checked","values","push","JSON","stringify","selectSelector","inputSelector","selected","textarea","originalText","text","saveTurnEvaluationQuestions","viewingTurn","currentTurn","ensureTurnEvaluationQuestionsRendered","then","loadTurnEvaluationResponses","nextTurn","clearTurnEvaluationForm","prevTurn","showing","messageid","placeholder","remove","recentMessages","slice","isDuplicate","contentEl","msgContent","safeMessage","behavior","templateData","content","id","turn_id","render","html","appendNodeContents","setTimeout","scrollToBottom","catch","messageHtml","append","params","URLSearchParams","action","sesskey","Config","fetch","wwwroot","method","headers","response","ok","Error","status","json","hide","success","parentid","userMessages","filter","lastUserMsg","last","currentId","startsWith","user_message_turn_id","displayAIMessage","focus","requestAnimationFrame","scrollTop","scrollHeight","containerWrapper","Promise","resolve","existingContainer","loadTurnEvaluationQuestions","questionsDataEl","questionsForTurn","parse","q","min_turn","containerHtml","questionsCount","Templates","questions","has_questions","reject","savePromises","Object","keys","map","questionid","url","all","results","every","r","floor","forEach","showTurnEvaluationTimestamp","responseData","timestamp","timemodified","Array","isArray","selector","hideTurnEvaluationTimestamp","questionItem","datetimeStr","toLocaleString","turn","prevBtn","nextBtn","sendBtn","lockMessage","showPrevious","toggleContainer","hasPreviousMessages","messageTurnId","msgTurn","removeClass","addClass","toggleBtn"],"mappings":"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"}